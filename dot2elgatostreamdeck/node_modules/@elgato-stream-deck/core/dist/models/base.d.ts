/// <reference types="node" />
import * as EventEmitter from 'eventemitter3';
import { HIDDevice } from '../device';
import { DeviceModelId, EncoderIndex, KeyIndex } from '../id';
import { FillImageOptions, FillLcdImageOptions, FillPanelOptions, LcdSegmentSize, StreamDeck, StreamDeckEvents } from '../types';
export declare type EncodeJPEGHelper = (buffer: Buffer, width: number, height: number) => Promise<Buffer>;
export interface OpenStreamDeckOptions {
    useOriginalKeyOrder?: boolean;
    encodeJPEG?: EncodeJPEGHelper;
}
export declare type StreamDeckProperties = Readonly<{
    MODEL: DeviceModelId;
    PRODUCT_NAME: string;
    COLUMNS: number;
    ROWS: number;
    ICON_SIZE: number;
    KEY_DIRECTION: 'ltr' | 'rtl';
    KEY_DATA_OFFSET: number;
}>;
export interface InternalFillImageOptions extends FillImageOptions {
    offset: number;
    stride: number;
}
export declare abstract class StreamDeckInputBase extends EventEmitter<StreamDeckEvents> implements StreamDeck {
    get NUM_KEYS(): number;
    get KEY_COLUMNS(): number;
    get KEY_ROWS(): number;
    get NUM_ENCODERS(): number;
    get LCD_STRIP_SIZE(): LcdSegmentSize | undefined;
    get LCD_ENCODER_SIZE(): LcdSegmentSize | undefined;
    get ICON_SIZE(): number;
    get ICON_BYTES(): number;
    get ICON_PIXELS(): number;
    get MODEL(): DeviceModelId;
    get PRODUCT_NAME(): string;
    protected readonly device: HIDDevice;
    protected readonly deviceProperties: Readonly<StreamDeckProperties>;
    private readonly keyState;
    constructor(device: HIDDevice, _options: OpenStreamDeckOptions, properties: StreamDeckProperties);
    protected handleInputBuffer(data: Uint8Array): void;
    checkValidKeyIndex(keyIndex: KeyIndex): void;
    close(): Promise<void>;
    abstract setBrightness(percentage: number): Promise<void>;
    abstract resetToLogo(): Promise<void>;
    abstract getFirmwareVersion(): Promise<string>;
    abstract getSerialNumber(): Promise<string>;
    protected transformKeyIndex(keyIndex: KeyIndex): KeyIndex;
    abstract fillKeyColor(keyIndex: KeyIndex, r: number, g: number, b: number): Promise<void>;
    abstract fillKeyBuffer(keyIndex: KeyIndex, imageBuffer: Buffer, options?: FillImageOptions): Promise<void>;
    abstract fillPanelBuffer(imageBuffer: Buffer, options?: FillPanelOptions): Promise<void>;
    fillEncoderLcd(_index: EncoderIndex, _buffer: Buffer, _sourceOptions: FillImageOptions): Promise<void>;
    fillLcdRegion(_x: number, _y: number, _imageBuffer: Buffer, _sourceOptions: FillLcdImageOptions): Promise<void>;
    abstract clearKey(keyIndex: KeyIndex): Promise<void>;
    abstract clearPanel(): Promise<void>;
}
export declare abstract class StreamDeckBase extends StreamDeckInputBase {
    fillKeyColor(keyIndex: KeyIndex, r: number, g: number, b: number): Promise<void>;
    fillKeyBuffer(keyIndex: KeyIndex, imageBuffer: Buffer, options?: FillImageOptions): Promise<void>;
    fillPanelBuffer(imageBuffer: Buffer, options?: FillPanelOptions): Promise<void>;
    clearKey(keyIndex: KeyIndex): Promise<void>;
    clearPanel(): Promise<void>;
    protected abstract convertFillImage(imageBuffer: Buffer, sourceOptions: InternalFillImageOptions): Promise<Buffer>;
    protected getFillImageCommandHeaderLength(): number;
    protected writeFillImageCommandHeader(buffer: Buffer, keyIndex: number, partIndex: number, isLast: boolean, _bodyLength: number): void;
    protected abstract getFillImagePacketLength(): number;
    protected generateFillImageWrites(keyIndex: KeyIndex, byteBuffer: Buffer): Buffer[];
    private fillImageRange;
    private checkRGBValue;
    private checkSourceFormat;
}
//# sourceMappingURL=base.d.ts.map