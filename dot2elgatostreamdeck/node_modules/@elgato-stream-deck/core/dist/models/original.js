"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckOriginal = void 0;
const util_1 = require("../util");
const base_gen1_1 = require("./base-gen1");
const id_1 = require("../id");
const originalProperties = {
    MODEL: id_1.DeviceModelId.ORIGINAL,
    PRODUCT_NAME: 'Streamdeck',
    COLUMNS: 5,
    ROWS: 3,
    ICON_SIZE: 72,
    KEY_DIRECTION: 'rtl',
    KEY_DATA_OFFSET: 0,
};
class StreamDeckOriginal extends base_gen1_1.StreamDeckGen1Base {
    constructor(device, options) {
        super(device, options, originalProperties);
        this.useOriginalKeyOrder = !!options.useOriginalKeyOrder;
    }
    transformKeyIndex(keyIndex) {
        if (!this.useOriginalKeyOrder) {
            // Horizontal flip
            const half = (this.KEY_COLUMNS - 1) / 2;
            const diff = ((keyIndex % this.KEY_COLUMNS) - half) * -half;
            return keyIndex + diff;
        }
        else {
            return keyIndex;
        }
    }
    getFillImagePacketLength() {
        return 8191;
    }
    async convertFillImage(sourceBuffer, sourceOptions) {
        const byteBuffer = (0, util_1.imageToByteArray)(sourceBuffer, sourceOptions, { colorMode: 'bgr', xFlip: true }, util_1.BMP_HEADER_LENGTH, this.ICON_SIZE);
        (0, util_1.writeBMPHeader)(byteBuffer, this.ICON_SIZE, this.ICON_BYTES, 3780);
        return Promise.resolve(byteBuffer);
    }
    generateFillImageWrites(keyIndex, byteBuffer) {
        const MAX_PACKET_SIZE = this.getFillImagePacketLength();
        const PACKET_HEADER_LENGTH = this.getFillImageCommandHeaderLength();
        // The original uses larger packets, and splits the payload equally across 2
        const packet1Bytes = byteBuffer.length / 2;
        const packet1 = Buffer.alloc(MAX_PACKET_SIZE);
        this.writeFillImageCommandHeader(packet1, keyIndex, 0x01, false, packet1Bytes);
        byteBuffer.copy(packet1, PACKET_HEADER_LENGTH, 0, packet1Bytes);
        const packet2 = Buffer.alloc(MAX_PACKET_SIZE);
        this.writeFillImageCommandHeader(packet2, keyIndex, 0x02, true, packet1Bytes);
        byteBuffer.copy(packet2, PACKET_HEADER_LENGTH, packet1Bytes);
        return [packet1, packet2];
    }
}
exports.StreamDeckOriginal = StreamDeckOriginal;
//# sourceMappingURL=original.js.map