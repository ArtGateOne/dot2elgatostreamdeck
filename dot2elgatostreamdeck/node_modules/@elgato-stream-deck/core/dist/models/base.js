"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckBase = exports.StreamDeckInputBase = void 0;
const EventEmitter = require("eventemitter3");
class StreamDeckInputBase extends EventEmitter {
    constructor(device, _options, properties) {
        super();
        this.deviceProperties = properties;
        this.device = device;
        this.keyState = new Array(this.NUM_KEYS).fill(false);
        this.device.on('input', (data) => this.handleInputBuffer(data));
        this.device.on('error', (err) => {
            this.emit('error', err);
        });
    }
    get NUM_KEYS() {
        return this.KEY_COLUMNS * this.KEY_ROWS;
    }
    get KEY_COLUMNS() {
        return this.deviceProperties.COLUMNS;
    }
    get KEY_ROWS() {
        return this.deviceProperties.ROWS;
    }
    get NUM_ENCODERS() {
        // Overridden by models which support this
        return 0;
    }
    get LCD_STRIP_SIZE() {
        // Overridden by models which support this
        return undefined;
    }
    get LCD_ENCODER_SIZE() {
        // Overridden by models which support this
        return undefined;
    }
    get ICON_SIZE() {
        return this.deviceProperties.ICON_SIZE;
    }
    get ICON_BYTES() {
        return this.ICON_PIXELS * 3;
    }
    get ICON_PIXELS() {
        return this.ICON_SIZE * this.ICON_SIZE;
    }
    get MODEL() {
        return this.deviceProperties.MODEL;
    }
    get PRODUCT_NAME() {
        return this.deviceProperties.PRODUCT_NAME;
    }
    handleInputBuffer(data) {
        const keyData = data.subarray(this.deviceProperties.KEY_DATA_OFFSET || 0);
        for (let i = 0; i < this.NUM_KEYS; i++) {
            const keyPressed = Boolean(keyData[i]);
            const keyIndex = this.transformKeyIndex(i);
            const stateChanged = keyPressed !== this.keyState[keyIndex];
            if (stateChanged) {
                this.keyState[keyIndex] = keyPressed;
                if (keyPressed) {
                    this.emit('down', keyIndex);
                }
                else {
                    this.emit('up', keyIndex);
                }
            }
        }
    }
    checkValidKeyIndex(keyIndex) {
        if (keyIndex < 0 || keyIndex >= this.NUM_KEYS) {
            throw new TypeError(`Expected a valid keyIndex 0 - ${this.NUM_KEYS - 1}`);
        }
    }
    async close() {
        return this.device.close();
    }
    transformKeyIndex(keyIndex) {
        return keyIndex;
    }
    async fillEncoderLcd(_index, _buffer, _sourceOptions) {
        throw new Error('Not supported for this model');
    }
    async fillLcdRegion(_x, _y, _imageBuffer, _sourceOptions) {
        throw new Error('Not supported for this model');
    }
}
exports.StreamDeckInputBase = StreamDeckInputBase;
class StreamDeckBase extends StreamDeckInputBase {
    async fillKeyColor(keyIndex, r, g, b) {
        this.checkValidKeyIndex(keyIndex);
        this.checkRGBValue(r);
        this.checkRGBValue(g);
        this.checkRGBValue(b);
        const pixels = Buffer.alloc(this.ICON_BYTES, Buffer.from([r, g, b]));
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        await this.fillImageRange(keyIndex2, pixels, {
            format: 'rgb',
            offset: 0,
            stride: this.ICON_SIZE * 3,
        });
    }
    async fillKeyBuffer(keyIndex, imageBuffer, options) {
        var _a;
        this.checkValidKeyIndex(keyIndex);
        const sourceFormat = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : 'rgb';
        this.checkSourceFormat(sourceFormat);
        const imageSize = this.ICON_PIXELS * sourceFormat.length;
        if (imageBuffer.length !== imageSize) {
            throw new RangeError(`Expected image buffer of length ${imageSize}, got length ${imageBuffer.length}`);
        }
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        await this.fillImageRange(keyIndex2, imageBuffer, {
            format: sourceFormat,
            offset: 0,
            stride: this.ICON_SIZE * sourceFormat.length,
        });
    }
    async fillPanelBuffer(imageBuffer, options) {
        var _a;
        const sourceFormat = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : 'rgb';
        this.checkSourceFormat(sourceFormat);
        const imageSize = this.ICON_PIXELS * sourceFormat.length * this.NUM_KEYS;
        if (imageBuffer.length !== imageSize) {
            throw new RangeError(`Expected image buffer of length ${imageSize}, got length ${imageBuffer.length}`);
        }
        const iconSize = this.ICON_SIZE * sourceFormat.length;
        const stride = iconSize * this.KEY_COLUMNS;
        const ps = [];
        for (let row = 0; row < this.KEY_ROWS; row++) {
            const rowOffset = stride * row * this.ICON_SIZE;
            for (let column = 0; column < this.KEY_COLUMNS; column++) {
                let index = row * this.KEY_COLUMNS;
                if (this.deviceProperties.KEY_DIRECTION === 'ltr') {
                    index += column;
                }
                else {
                    index += this.KEY_COLUMNS - column - 1;
                }
                const colOffset = column * iconSize;
                ps.push(this.fillImageRange(index, imageBuffer, {
                    format: sourceFormat,
                    offset: rowOffset + colOffset,
                    stride,
                }));
            }
        }
        await Promise.all(ps);
    }
    async clearKey(keyIndex) {
        this.checkValidKeyIndex(keyIndex);
        const pixels = Buffer.alloc(this.ICON_BYTES, 0);
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        await this.fillImageRange(keyIndex2, pixels, {
            format: 'rgb',
            offset: 0,
            stride: this.ICON_SIZE * 3,
        });
    }
    async clearPanel() {
        const pixels = Buffer.alloc(this.ICON_BYTES, 0);
        const ps = [];
        for (let keyIndex = 0; keyIndex < this.NUM_KEYS; keyIndex++) {
            ps.push(this.fillImageRange(keyIndex, pixels, {
                format: 'rgb',
                offset: 0,
                stride: this.ICON_SIZE * 3,
            }));
        }
        await Promise.all(ps);
    }
    getFillImageCommandHeaderLength() {
        return 16;
    }
    writeFillImageCommandHeader(buffer, keyIndex, partIndex, isLast, _bodyLength) {
        buffer.writeUInt8(0x02, 0);
        buffer.writeUInt8(0x01, 1);
        buffer.writeUInt16LE(partIndex, 2);
        // 3 = 0x00
        buffer.writeUInt8(isLast ? 1 : 0, 4);
        buffer.writeUInt8(keyIndex + 1, 5);
    }
    generateFillImageWrites(keyIndex, byteBuffer) {
        const MAX_PACKET_SIZE = this.getFillImagePacketLength();
        const PACKET_HEADER_LENGTH = this.getFillImageCommandHeaderLength();
        const MAX_PAYLOAD_SIZE = MAX_PACKET_SIZE - PACKET_HEADER_LENGTH;
        const result = [];
        let remainingBytes = byteBuffer.length;
        for (let part = 0; remainingBytes > 0; part++) {
            const packet = Buffer.alloc(MAX_PACKET_SIZE);
            const byteCount = Math.min(remainingBytes, MAX_PAYLOAD_SIZE);
            this.writeFillImageCommandHeader(packet, keyIndex, part, remainingBytes <= MAX_PAYLOAD_SIZE, byteCount);
            const byteOffset = byteBuffer.length - remainingBytes;
            remainingBytes -= byteCount;
            byteBuffer.copy(packet, PACKET_HEADER_LENGTH, byteOffset, byteOffset + byteCount);
            result.push(packet);
        }
        return result;
    }
    async fillImageRange(keyIndex, imageBuffer, sourceOptions) {
        this.checkValidKeyIndex(keyIndex);
        const byteBuffer = await this.convertFillImage(imageBuffer, sourceOptions);
        const packets = this.generateFillImageWrites(keyIndex, byteBuffer);
        await this.device.sendReports(packets);
    }
    checkRGBValue(value) {
        if (value < 0 || value > 255) {
            throw new TypeError('Expected a valid color RGB value 0 - 255');
        }
    }
    checkSourceFormat(format) {
        switch (format) {
            case 'rgb':
            case 'rgba':
            case 'bgr':
            case 'bgra':
                break;
            default: {
                const fmt = format;
                throw new TypeError(`Expected a known color format not "${fmt}"`);
            }
        }
    }
}
exports.StreamDeckBase = StreamDeckBase;
//# sourceMappingURL=base.js.map