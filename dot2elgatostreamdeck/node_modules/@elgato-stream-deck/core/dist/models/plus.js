"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _StreamDeckPlus_encoderState;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckPlus = void 0;
const util_1 = require("../util");
const base_gen2_1 = require("./base-gen2");
const id_1 = require("../id");
const plusProperties = {
    MODEL: id_1.DeviceModelId.PLUS,
    PRODUCT_NAME: 'Streamdeck +',
    COLUMNS: 4,
    ROWS: 2,
    ICON_SIZE: 120,
    KEY_DIRECTION: 'ltr',
    KEY_DATA_OFFSET: 3,
};
class StreamDeckPlus extends base_gen2_1.StreamDeckGen2Base {
    constructor(device, options) {
        super(device, options, plusProperties, true);
        _StreamDeckPlus_encoderState.set(this, void 0);
        __classPrivateFieldSet(this, _StreamDeckPlus_encoderState, new Array(4).fill(false), "f");
    }
    get NUM_ENCODERS() {
        return 4;
    }
    get LCD_STRIP_SIZE() {
        const size = this.LCD_ENCODER_SIZE;
        size.width *= this.NUM_ENCODERS;
        return size;
    }
    get LCD_ENCODER_SIZE() {
        return { width: 200, height: 100 };
    }
    calculateEncoderForX(x) {
        const encoderWidth = this.LCD_ENCODER_SIZE.width;
        return Math.floor(x / encoderWidth);
    }
    handleInputBuffer(data) {
        const inputType = data[0];
        switch (inputType) {
            case 0x00: // Button
                super.handleInputBuffer(data);
                break;
            case 0x02: // LCD
                this.handleLcdInput(data);
                break;
            case 0x03: // Encoder
                this.handleEncoderInput(data);
                break;
        }
    }
    handleLcdInput(data) {
        const buffer = Buffer.from(data);
        const position = {
            x: buffer.readUint16LE(5),
            y: buffer.readUint16LE(7),
        };
        const index = this.calculateEncoderForX(position.x);
        switch (data[3]) {
            case 0x01: // short press
                this.emit('lcdShortPress', index, position);
                break;
            case 0x02: // long press
                this.emit('lcdLongPress', index, position);
                break;
            case 0x03: {
                // swipe
                const position2 = {
                    x: buffer.readUint16LE(9),
                    y: buffer.readUint16LE(11),
                };
                const index2 = this.calculateEncoderForX(position2.x);
                this.emit('lcdSwipe', index, index2, position, position2);
                break;
            }
        }
    }
    handleEncoderInput(data) {
        switch (data[3]) {
            case 0x00: // press/release
                for (let keyIndex = 0; keyIndex < this.NUM_ENCODERS; keyIndex++) {
                    const keyPressed = Boolean(data[4 + keyIndex]);
                    const stateChanged = keyPressed !== __classPrivateFieldGet(this, _StreamDeckPlus_encoderState, "f")[keyIndex];
                    if (stateChanged) {
                        __classPrivateFieldGet(this, _StreamDeckPlus_encoderState, "f")[keyIndex] = keyPressed;
                        if (keyPressed) {
                            this.emit('encoderDown', keyIndex);
                        }
                        else {
                            this.emit('encoderUp', keyIndex);
                        }
                    }
                }
                break;
            case 0x01: // rotate
                for (let keyIndex = 0; keyIndex < this.NUM_ENCODERS; keyIndex++) {
                    const intArray = new Int8Array(data.buffer, data.byteOffset, data.byteLength);
                    const value = intArray[4 + keyIndex];
                    if (value > 0) {
                        this.emit('rotateRight', keyIndex, value);
                    }
                    else if (value < 0) {
                        this.emit('rotateLeft', keyIndex, -value);
                    }
                }
                break;
        }
    }
    async clearPanel() {
        const clearButtons = super.clearPanel();
        const lcdSize = this.LCD_STRIP_SIZE;
        const buffer = Buffer.alloc(lcdSize.width * lcdSize.height * 4);
        const clearLcd = this.fillLcdRegion(0, 0, buffer, {
            format: 'rgba',
            width: lcdSize.width,
            height: lcdSize.height,
        });
        await Promise.all([clearButtons, clearLcd]);
    }
    async fillEncoderLcd(index, buffer, sourceOptions) {
        if (this.NUM_ENCODERS === 0)
            throw new Error(`There are no encoders`);
        const size = this.LCD_ENCODER_SIZE;
        const x = index * size.width;
        return this.fillLcdRegion(x, 0, buffer, {
            format: sourceOptions.format,
            width: size.width,
            height: size.height,
        });
    }
    async fillLcdRegion(x, y, imageBuffer, sourceOptions) {
        // Basic bounds checking
        const maxSize = this.LCD_STRIP_SIZE;
        if (x < 0 || x + sourceOptions.width > maxSize.width) {
            throw new TypeError(`Image will not fit within the lcd strip`);
        }
        if (y < 0 || y + sourceOptions.height > maxSize.height) {
            throw new TypeError(`Image will not fit within the lcd strip`);
        }
        const imageSize = sourceOptions.width * sourceOptions.height * sourceOptions.format.length;
        if (imageBuffer.length !== imageSize) {
            throw new RangeError(`Expected image buffer of length ${imageSize}, got length ${imageBuffer.length}`);
        }
        // A lot of this drawing code is heavily based on the normal button
        const byteBuffer = await this.convertFillLcdBuffer(imageBuffer, sourceOptions);
        const packets = this.generateFillLcdWrites(x, y, byteBuffer, sourceOptions);
        await this.device.sendReports(packets);
    }
    async convertFillLcdBuffer(sourceBuffer, sourceOptions) {
        const sourceOptions2 = {
            format: sourceOptions.format,
            offset: 0,
            stride: sourceOptions.width * sourceOptions.format.length,
        };
        const byteBuffer = (0, util_1.imageToByteArray)(sourceBuffer, sourceOptions2, { colorMode: 'rgba', xFlip: this.xyFlip, yFlip: this.xyFlip }, 0, sourceOptions.width, sourceOptions.height);
        return this.encodeJPEG(byteBuffer, sourceOptions.width, sourceOptions.height);
    }
    generateFillLcdWrites(x, y, byteBuffer, sourceOptions) {
        const MAX_PACKET_SIZE = 1024; // this.getFillImagePacketLength()
        const PACKET_HEADER_LENGTH = 16;
        const MAX_PAYLOAD_SIZE = MAX_PACKET_SIZE - PACKET_HEADER_LENGTH;
        const result = [];
        let remainingBytes = byteBuffer.length;
        for (let part = 0; remainingBytes > 0; part++) {
            const packet = Buffer.alloc(MAX_PACKET_SIZE);
            const byteCount = Math.min(remainingBytes, MAX_PAYLOAD_SIZE);
            packet.writeUInt8(0x02, 0);
            packet.writeUInt8(0x0c, 1);
            packet.writeUInt16LE(x, 2);
            packet.writeUInt16LE(y, 4);
            packet.writeUInt16LE(sourceOptions.width, 6);
            packet.writeUInt16LE(sourceOptions.height, 8);
            packet.writeUInt8(remainingBytes <= MAX_PAYLOAD_SIZE ? 1 : 0, 10); // Is last
            packet.writeUInt16LE(part, 11);
            packet.writeUInt16LE(byteCount, 13);
            const byteOffset = byteBuffer.length - remainingBytes;
            remainingBytes -= byteCount;
            byteBuffer.copy(packet, PACKET_HEADER_LENGTH, byteOffset, byteOffset + byteCount);
            result.push(packet);
        }
        return result;
    }
}
exports.StreamDeckPlus = StreamDeckPlus;
_StreamDeckPlus_encoderState = new WeakMap();
//# sourceMappingURL=plus.js.map