"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckProxy = void 0;
/**
 * A minimal proxy around a StreamDeck instance.
 * This is intended to be used by libraries wrapping this that want to add more methods to the StreamDeck
 */
class StreamDeckProxy {
    constructor(device) {
        this.device = device;
    }
    get NUM_KEYS() {
        return this.device.NUM_KEYS;
    }
    get KEY_COLUMNS() {
        return this.device.KEY_COLUMNS;
    }
    get KEY_ROWS() {
        return this.device.KEY_ROWS;
    }
    get NUM_ENCODERS() {
        return this.device.NUM_ENCODERS;
    }
    get LCD_STRIP_SIZE() {
        return this.device.LCD_STRIP_SIZE;
    }
    get LCD_ENCODER_SIZE() {
        return this.device.LCD_ENCODER_SIZE;
    }
    get ICON_SIZE() {
        return this.device.ICON_SIZE;
    }
    get ICON_BYTES() {
        return this.device.ICON_BYTES;
    }
    get ICON_PIXELS() {
        return this.device.ICON_PIXELS;
    }
    get MODEL() {
        return this.device.MODEL;
    }
    get PRODUCT_NAME() {
        return this.device.PRODUCT_NAME;
    }
    checkValidKeyIndex(keyIndex) {
        this.device.checkValidKeyIndex(keyIndex);
    }
    async close() {
        return this.device.close();
    }
    async fillKeyColor(keyIndex, r, g, b) {
        return this.device.fillKeyColor(keyIndex, r, g, b);
    }
    async fillKeyBuffer(keyIndex, imageBuffer, options) {
        return this.device.fillKeyBuffer(keyIndex, imageBuffer, options);
    }
    async fillPanelBuffer(imageBuffer, options) {
        return this.device.fillPanelBuffer(imageBuffer, options);
    }
    async clearKey(keyIndex) {
        return this.device.clearKey(keyIndex);
    }
    async clearPanel() {
        return this.device.clearPanel();
    }
    async setBrightness(percentage) {
        return this.device.setBrightness(percentage);
    }
    async resetToLogo() {
        return this.device.resetToLogo();
    }
    async getFirmwareVersion() {
        return this.device.getFirmwareVersion();
    }
    async getSerialNumber() {
        return this.device.getSerialNumber();
    }
    async fillEncoderLcd(index, imageBuffer, sourceOptions) {
        return this.device.fillEncoderLcd(index, imageBuffer, sourceOptions);
    }
    async fillLcdRegion(x, y, imageBuffer, sourceOptions) {
        return this.device.fillLcdRegion(x, y, imageBuffer, sourceOptions);
    }
    /**
     * EventEmitter
     */
    eventNames() {
        return this.device.eventNames();
    }
    listeners(event) {
        return this.device.listeners(event);
    }
    listenerCount(event) {
        return this.device.listenerCount(event);
    }
    emit(event, ...args) {
        return this.device.emit(event, ...args);
    }
    /**
     * Add a listener for a given event.
     */
    on(event, fn, context) {
        this.device.on(event, fn, context);
        return this;
    }
    addListener(event, fn, context) {
        this.device.addListener(event, fn, context);
        return this;
    }
    /**
     * Add a one-time listener for a given event.
     */
    once(event, fn, context) {
        this.device.once(event, fn, context);
        return this;
    }
    /**
     * Remove the listeners of a given event.
     */
    removeListener(event, fn, context, once) {
        this.device.removeListener(event, fn, context, once);
        return this;
    }
    off(event, fn, context, once) {
        this.device.off(event, fn, context, once);
        return this;
    }
    removeAllListeners(event) {
        this.device.removeAllListeners(event);
        return this;
    }
}
exports.StreamDeckProxy = StreamDeckProxy;
//# sourceMappingURL=proxy.js.map