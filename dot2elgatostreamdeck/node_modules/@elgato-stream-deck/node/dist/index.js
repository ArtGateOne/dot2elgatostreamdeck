"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.openStreamDeck = exports.getStreamDeckInfo = exports.getStreamDeckDeviceInfo = exports.listStreamDecks = exports.DeviceModelId = void 0;
const core_1 = require("@elgato-stream-deck/core");
const HID = require("node-hid");
const device_1 = require("./device");
const jpeg_1 = require("./jpeg");
const wrapper_1 = require("./wrapper");
var core_2 = require("@elgato-stream-deck/core");
Object.defineProperty(exports, "DeviceModelId", { enumerable: true, get: function () { return core_2.DeviceModelId; } });
/**
 * Scan for and list detected devices
 */
function listStreamDecks() {
    const devices = {};
    for (const dev of HID.devices()) {
        if (dev.path && !devices[dev.path]) {
            const info = getStreamDeckDeviceInfo(dev);
            if (info)
                devices[dev.path] = info;
        }
    }
    return Object.values(devices);
}
exports.listStreamDecks = listStreamDecks;
/**
 * If the provided device is a streamdeck, get the info about it
 */
function getStreamDeckDeviceInfo(dev) {
    const model = core_1.DEVICE_MODELS.find((m) => m.productId === dev.productId);
    if (model && dev.vendorId === core_1.VENDOR_ID && dev.path) {
        return {
            model: model.id,
            path: dev.path,
            serialNumber: dev.serialNumber,
        };
    }
    else {
        return null;
    }
}
exports.getStreamDeckDeviceInfo = getStreamDeckDeviceInfo;
/**
 * Get the info of a device if the given path is a streamdeck
 */
function getStreamDeckInfo(path) {
    return listStreamDecks().find((dev) => dev.path === path);
}
exports.getStreamDeckInfo = getStreamDeckInfo;
/**
 * Open a streamdeck
 * @param devicePath The path of the device to open. If not set, the first will be used
 * @param userOptions Options to customise the device behvaiour
 */
function openStreamDeck(devicePath, userOptions) {
    var _a;
    let foundDevices = listStreamDecks();
    if (devicePath) {
        foundDevices = foundDevices.filter((d) => d.path === devicePath);
    }
    if (foundDevices.length === 0) {
        if (devicePath) {
            throw new Error(`Device "${devicePath}" was not found`);
        }
        else {
            throw new Error('No Stream Decks are connected.');
        }
    }
    const model = core_1.DEVICE_MODELS.find((m) => m.id === foundDevices[0].model);
    if (!model) {
        throw new Error('Stream Deck is of unexpected type.');
    }
    // Clone the options, to ensure they dont get changed
    const jpegOptions = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.jpegOptions)
        ? { ...userOptions.jpegOptions }
        : undefined;
    const options = {
        useOriginalKeyOrder: false,
        encodeJPEG: async (buffer, width, height) => (0, jpeg_1.encodeJPEG)(buffer, width, height, jpegOptions),
        ...userOptions,
    };
    const device = new device_1.NodeHIDDevice(foundDevices[0]);
    const rawSteamdeck = new model.class(device, options || {});
    return new wrapper_1.StreamDeckNode(rawSteamdeck, (_a = userOptions === null || userOptions === void 0 ? void 0 : userOptions.resetToLogoOnClose) !== null && _a !== void 0 ? _a : false);
}
exports.openStreamDeck = openStreamDeck;
//# sourceMappingURL=index.js.map