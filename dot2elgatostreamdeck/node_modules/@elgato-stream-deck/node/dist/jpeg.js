"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeJPEG = void 0;
const jpegJS = require("jpeg-js");
let jpegTurbo;
try {
    // eslint-disable-next-line node/no-extraneous-require
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    jpegTurbo = require('@julusian/jpeg-turbo');
}
catch (e) {
    // This is expected and can be ignored
}
const DEFAULT_QUALITY = 95;
/**
 * The default JPEG encoder.
 * `@julusian/jpeg-turbo` will be used if it can be found, otherwise it will fall back to `jpeg-js`
 * @param buffer The buffer to convert
 * @param width Width of the image
 * @param height Hieght of the image
 */
async function encodeJPEG(buffer, width, height, options) {
    try {
        // Try using jpeg-turbo if it is available
        if (jpegTurbo && jpegTurbo.bufferSize && !!jpegTurbo.compressSync) {
            const encodeOptions = {
                format: jpegTurbo.FORMAT_RGBA,
                width,
                height,
                quality: DEFAULT_QUALITY,
                ...options,
            };
            if (buffer.length === width * height * 4) {
                const tmpBuffer = Buffer.alloc(jpegTurbo.bufferSize(encodeOptions));
                return jpegTurbo.compress(buffer, tmpBuffer, encodeOptions);
            }
        }
    }
    catch (e) {
        // TODO - log error
        jpegTurbo = undefined;
    }
    // If jpeg-turbo is unavailable or fails, then fallback to jpeg-js
    const jpegBuffer2 = jpegJS.encode({
        width,
        height,
        data: buffer,
    }, options ? options.quality : DEFAULT_QUALITY);
    return Promise.resolve(jpegBuffer2.data);
}
exports.encodeJPEG = encodeJPEG;
//# sourceMappingURL=jpeg.js.map